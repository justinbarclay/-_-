* Twitter has put me in a vegetative state
** Like Gumby

The power and flexibility that Emacs, and it's suite of packages, constantly amazes me. I've been a big fan of `org-mode` for a long time, it's a great in Emacs replacement for Markdown and a number of other document formats, thanks to pandoc. `org-mode` is a great place to practice [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate programming]], but it's also a great place to an interactive style of programming, like a REPL or a Jupyter Notebook.

Lately, I've spent a lot of time exploring web APIs. I've tried a several tools over the years: Postman - back when it was a chrome extension, Curl, and HTTTPie. They were all, all right to get the job done, but they all ended up missing some feature or some UX. That's when I found [[https://github.com/pashky/restclient.el][restclient]], a package for Emacs with a `curl` like `DSL`.

#+BEGIN_SRC restclient
  // Here we will post our base64 encoded application token to get bearer token
  POST https://api.twitter.com/oauth2/token?grant_type=client_credentials
  Authorization: Basic eHZ6MWV2RlM0d0VFUFRHRUZQSEJvZzpMOHFxOVBaeVJnNmllS0dFS2hab2xHQzB2SldMdzhpRUo4OERSZHlPZw==
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js
{
  "token_type": "bearer",
  "access_token": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}
// POST https://api.twitter.com/oauth2/token?grant_type=client_credentials
// HTTP/1.1 200 OK
// cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0
// content-disposition: attachment; filename=json.json
// content-length: 155
// content-type: application/json;charset=utf-8
// date: Thu, 24 Jan 2019 05:54:09 GMT
// expires: Tue, 31 Mar 1981 05:00:00 GMT
// last-modified: Thu, 24 Jan 2019 05:54:09 GMT
// ml: S
// pragma: no-cache
// server: tsa_a
// status: 200 OK
// strict-transport-security: max-age=631138519
// x-connection-hash: b93d89db0ee8f4ea90991c99c8d58449
// x-content-type-options: nosniff
// x-frame-options: DENY
// x-response-time: 20
// x-transaction: 005403e60014e9ee
// x-twitter-response-tags: BouncerCompliant
// x-ua-compatible: IE=edge,chrome=1
// x-xss-protection: 1; mode=block; report=https://twitter.com/i/xss_report
// Request duration: 0.079710s
#+END_SRC


- However when I'm exploring APIs, first or third parties, I do it in a much more interactive manor: I'll take try stuff, I'll take notes, I'll cluster my API calls, I'll pre or post process the data. For me, this is a practice that lends it self a [[https://hub.mybinder.org/user/binder-examples-julia-python-h6xqlrbg/notebooks/julia.ipynb][notebook]] style of development.

- However, as an Emascist `org-mode`, and [[https://github.com/alf/ob-restclient.el][ob-restclient]], we can automate process further and share are work with out coworkers. I mean, that is if our coworkers had good taste and used Emacs over Vim, or Atom, or VSCode.

** Setup
First off, let's define a simple function to quickly clear out the result blocks in the current org file
#+BEGIN_SRC elisp
  (defun jb/org-clear-results ()
    (interactive)
    (org-babel-remove-result-one-or-many 't))
#+END_SRC

Now, let's set that to an easy to use key
#+BEGIN_SRC elisp
  (global-unset-key "\C-c\C-v\C-c")
  (global-set-key "\C-c\C-v\C-c" 'jb/org-clear-results)
#+END_SRC

We need a function to sanitize the response we get from restclient
#+BEGIN_SRC elisp
(defun sanitize-restclient-response (string)
 (string-trim (replace-regexp-in-string "^#\\+BEGIN_SRC js\\|^#\\+END_SRC\\|^//[[:print:]]+" "" string)))
#+END_SRC

Here's a couple of functions we're going to use to help us parse a response from Google's API.
#+BEGIN_SRC elisp
  (defun parse-ml-response (responses)
    "Extracts A Google AI response down to a list of label annotations"
    (let* ((json-response (json-read-from-string responses))
           (label-annotations  (cdr
                               (assoc 'labelAnnotations
                                      (elt
                                       (cdr (assoc 'responses json-response))
                                       0)))))
      label-annotations))

  (defun contains-description-p (annotations descriptions)
    "Checks to see if any of the items in the sequence ANNOTATIONS has a description that matches one of the items in DESCRIPTIONS"
    (let ((annotated-descriptions (mapcar (lambda (item) (cdr (assoc 'description item))) annotations)))
      (reduce (lambda (predicate description)
                (if predicate
                    predicate
                  (if (member description descriptions)
                      't
                    nil)))
              annotated-descriptions
              :initial-value nil)))
#+END_SRC

Finally we're going to want some code to run a specific source code block
#+BEGIN_SRC elisp
  (defun run-org-block ()
    (save-excursion
      (goto-char
       (org-babel-find-named-block
        (completing-read "Code Block: " (org-babel-src-block-names))))
      (org-babel-execute-src-block-maybe)))
#+END_SRC

** Preamble
I really like plants, and I love to learn random plant facts. So I am going to use [[https://trefle.io/reference][trefle.io]] API to tweet out facts about random plants.
** Demo
Let's give our source block a name, `#+NAME: trefle`, so we can easily reference it throughout the rest of our notebook. I am using my Mac's keychain to store and retrieve an access token I have stored for trefle.io.
#+NAME: trefle
#+BEGIN_SRC bash :results output
  security find-generic-password -gws trefle.io
#+END_SRC

To import a variable from earlier in the file you can use `:var token=trefle` where :var token, specified that you what to insert a variable called token into the proceeding block and the contents of that variable a pull from a block by the name of `trefle`. Now we just need to build the HTTP headers we're going to use for our interaction with trefle.
#+NAME: trefle-headers
#+BEGIN_SRC elisp :var token=trefle
  (concat
     "<<
  Content-Type: application/json
  Accept: application/json
  Authorization: Bearer " token)
#+END_SRC

As of the last time I looked, trefle.io has over 4000 pages of plants, so we want to get a random plant off of a random page. So to start, we'll generate a page number from 0 to 4000...
#+NAME: plants
#+BEGIN_SRC restclient :var headers=trefle-headers  :results value drawer
  #
  :page := (random 4000)
  GET https://trefle.io/api/plants?page=:page
  :headers
  #
#+END_SRC

Before we can do anything with the output we need to clean it up, restclient likes to have all the headers for the response at the bottom of the buffer, so we need to filter those out of the response.
#+NAME: sanitized-response
#+BEGIN_SRC elisp :var response=plants
(sanitize-restclient-response response)
#+END_SRC

Now we could use elisp, but everyone has NodeJS installed and NodeJS is pretty much built for parsing JSON, so it only makes sense to use that. So we'll grab a random plant from the sanitized results and return it's ID.

#+NAME: plant-name
#+BEGIN_SRC js :var plants=sanitized-response :results value drawer
  let index = Math.floor(Math.random() * 30);
  return JSON.parse(plants)[index].scientific_name;
#+END_SRC

Now, I need to get my Google API key, for this I've been lazy and have just been storing it as an ENV var.
#+NAME: google-api-key
#+BEGIN_SRC bash
  echo $GOOGLE_API_KEY
#+END_SRC

Now that we've got a plant name, let's get an image to use to give an example of the plant.

#+NAME: google-images
#+BEGIN_SRC restclient :var api-key=google-api-key plant-name=plant-name
  GET https://content.googleapis.com/customsearch/v1?cx=009341007550343915479%3Afg_hsgzltxw&q=:plant-name&searchType=image&key=:api-key
#+END_SRC

Now much like our search for a plant name, we need to clean up the response from google API so it's easily parsable as JSON.
#+NAME: flower-images
#+BEGIN_SRC elisp :var google-images=google-images
  (sanitize-restclient-response google-images)
#+END_SRC

Now that we have a nice list of plants, let's play google roulette and use the first image from the search.

#+NAME: plant-image
#+BEGIN_SRC js :var plant_images=flower-images :results value drawer
  return "" + JSON.parse(plant_images).items[0].link
#+END_SRC

But how can we be sure to trust Google? We don't have time to make sure all of our code does what it is actually supposed to do. In stead, we'll use Machine Learning provided by the fabulous Google to ensure our image is what we expect it to be.
#+NAME: plant-ml-results
#+BEGIN_SRC restclient :var api-key=google-api-key plant-image=plant-image
POST https://vision.googleapis.com/v1/images:annotate?key=:api-key
{
  "requests":[
    {
      "image":{
        "source":{
          "imageUri":
           :plant-image
        }
      },
      "features":[
        {
          "type":"LABEL_DETECTION",
          "maxResults":3
        }
      ]
    }
  ]
  }
#+END_SRC

Again some data clean up
#+NAME: sanitized-ml-results
#+BEGIN_SRC elisp :var response=plant-ml-results
(sanitize-restclient-response response)
#+END_SRC

#+NAME: sanitized-ml-results
#+begin_example
{
  "responses": [
    {
      "labelAnnotations": [
        {
          "mid": "/m/04_tb",
          "description": "map",
          "score": 0.9684097,
          "topicality": 0.9684097
        },
        {
          "mid": "/m/03scnj",
          "description": "line",
          "score": 0.734654,
          "topicality": 0.734654
        },
        {
          "mid": "/m/07j7r",
          "description": "tree",
          "score": 0.7276011,
          "topicality": 0.7276011
        }
      ]
    }
  ]
}
#+end_example

Let's check to see if the first three descriptors come back as plant, tree, or a flower
#+NAME: image-is-plant-p
#+BEGIN_SRC elisp :var response=sanitized-ml-results
  (contains-description-p
   (parse-ml-response response)
   '("plant" "tree" "flower"))
#+END_SRC

We need one last piece of information before we can demonstrate our love of Plants to the world, someone to tweet at. Let's ask ourselves for some input.
#+NAME: twitter-handle
#+BEGIN_SRC elisp
(read-string "What is the twitter handle of someone you want to tweet? ")
#+END_SRC

# First we'll need to do some prep work before we can authenticate with twitter. In [[https://developer.twitter.com/en/docs/basics/authentication/overview/application-only#step-1-encode-consumer-key-and-secret][Step 1]] of the Twitter tutorial for authentication, we need to encode our tokens according to RFC 1738, join them with a colon, and then base64 encode the result. In the snippet below we're going to use an elisp function that follows RFC 1738, so we don't have to do it manually.

# #+NAME: twitter-auth-header
# #+BEGIN_SRC elisp :var consumer-key=twitter-consumer-key consumer-secret=twitter-consumer-secret
#   (defun build-bearer-token ()
#     (replace-regexp-in-string "\n" ""
#     (base64-encode-string
#      (concat
#       (url-hexify-string consumer-key)
#       ":"
#       (url-hexify-string consumer-secret)))))

#   (concat
#    "<<
#   Content-Type: application/x-www-form-urlencoded;charset=UTF-8
#   Authorization: Basic "
#    (string-trim
#     (build-bearer-token)))
# #+END_SRC

# Great now, that we've got our bearer token, on to [[https://developer.twitter.com/en/docs/basics/authentication/overview/application-only#step-2-obtain-a-bearer-token][Step 2]].
# #+NAME: twitter-bearer-token
# #+BEGIN_SRC restclient :var auth-headers=twitter-auth-header
#   #
#   POST https://api.twitter.com/oauth2/token
#   :auth-headers
#   grant_type=client_credentials
# #+END_SRC

# Now that we have a token we need to clean it up so we can parse it else where...
# #+NAME: sanitize-twitter-token
# #+BEGIN_SRC elisp :var response=twitter-bearer-token
#   (sanitize-restclient-response response)
# #+END_SRC

# #+NAME: parsed-twitter-token
# #+BEGIN_SRC js :var response=sanitize-twitter-token :results drawer
#   return JSON.parse(response)["access_token"];
# #+END_SRC

** Twitter
*** Helper functions
#+BEGIN_SRC elisp
  (defun twitter-signing-key (consumer-secret token-secret)
    "Creates a signing key by combining the consumer-secret and the token secret and percent encoding the result"
    (concat
     (url-encode-url
      consumer-secret)
     "&"
     (url-encode-url
      token-secret)))

  (defun twitter-signature-string (method base params)
    (let ((sorted-params
           (sort params
                 (lambda (first second)
                   (string< (car first) (car second))))))
      (concat
       method
       "&"
       (url-hexify-string base)
       "&"
       (url-hexify-string
        (mapconcat
         (lambda (entry)
           (let ((key (car entry))
                 (value (cdr entry)))
             (concat (url-hexify-string key)
                     "="
                     (url-hexify-string value))))
         sorted-params
         "&")))))

  (defun build-twitter-header-string (header oauth-headers)
    "Takes in a list of cons cells that represent HTTP headers, as well as the information needed to define the OAUTH response for a Twitter request, and build a restclient style header string"
    (concat
     "<<\n"
     (mapconcat
      (lambda (entry)
        (let ((key (car entry))
              (value (cdr entry)))
          (concat
           key
           ": "
           value
           " ")))
      header
      "")
     "\nAuthorization: OAuth "
     (string-trim-right
      (mapconcat
       (lambda (entry)
         (let ((key (car entry))
               (value (cdr entry)))
           (concat
            key
            "="
            "\"" value "\""
            ",")))
       oauth-headers
       " ")
      ",")))
#+END_SRC

*** Shhh it's Secret
Let's get all the keys we need to interact with the twitter api.
#+NAME: twitter-consumer-key
#+BEGIN_SRC sh
echo $TWITTER_CONSUMER_KEY
#+END_SRC

#+NAME: twitter-consumer-secret
#+BEGIN_SRC sh
echo $TWITTER_CONSUMER_SECRET
#+END_SRC

#+NAME: twitter-access-token
#+BEGIN_SRC sh
echo $TWITTER_ACCESS_TOKEN
#+END_SRC

#+NAME: twitter-access-secret
#+BEGIN_SRC sh
echo $TWITTER_ACCESS_SECRET
#+END_SRC

*** Functions stuff
**** Let's generating content
#+NAME: xtwitter-body
#+BEGIN_SRC elisp :var plant_name=plant-name plant_image=plant-image twitter_handle=twitter-handle
  (setq twitter-body
   (list
    (cons "status" (concat "" twitter_handle " " plant_name " " (replace-regexp-in-string "'" "" plant_image)))))
#+END_SRC

#+NAME: twitter-body-generated
#+BEGIN_SRC elisp
 (list (cons "status" "@spiralganglion 'Lathyrus laetivirens' https://www.pacificbulbsociety.org/pbswiki/files/Alpinia/Alpinia_carolinensis1NN.jpg"))
#+END_SRC

**** Let's work on Auth
***** Step 1 Header creation and Signing the Header
To start we need to autogenerate a few pieces of information; a nonce, a none a timestamp and the signature.

Emacs's doesn't really have a built in crypto library and Ruby is  a fun language with a pretty full featured STL, let's use it to generate our Nonce
#+NAME: nonce
#+BEGIN_SRC ruby
require 'securerandom'

nonce = SecureRandom.uuid
nonce.gsub(/\W/, "")
#+END_SRC

We need the current time of our request
#+NAME: oauth-time
#+BEGIN_SRC elisp
  (format-time-string "%s")
#+END_SRC

We need to define the headers that we need for this request.
#+NAME: twitter-headers
#+BEGIN_SRC elisp
(list
 (cons "Content-Type" "application/x-www-form-urlencoded"))
#+END_SRC

Surprisingly, Emacs doesn't really have the best built in crypto support, so we'll need to let another language do the heavy lifting. I like Node and Node has a decent crypto library built into it.
#+NAME: createSignature
#+BEGIN_SRC js :var signature_string="" :var key=""
  let crypto = require('crypto')

  let createSignature = (key, text) => {
    return crypto.createHmac('sha1', key).update(signature_string).digest('bindary');
  }

  return createSignature(key, signature_string).toString('base64');
#+END_SRC


Now before we can sign anything, and in the next block we need to sign things, we need to create a signing key.
#+NAME: signing-key
#+BEGIN_SRC elisp :var consumer-secret=twitter-consumer-secret token-secret=twitter-access-secret
  (twitter-signing-key consumer-secret token-secret)
#+END_SRC

Next up, is the oauth specific headers needed for the request
#+NAME: twitter-oauth-headers
#+BEGIN_SRC elisp :var nonce=nonce consumer-key=twitter-consumer-key access-token=twitter-access-token oauth-time=oauth-time body=twitter-body- signing-key=signing-key
  (let*
      ((twitter-oauth-headers
        (list
         (cons "oauth_consumer_key" consumer-key)
         (cons "oauth_nonce" nonce)
         (cons "oauth_signature_method" "HMAC-SHA1")
         (cons "oauth_timestamp" oauth-time)
         (cons "oauth_token" access-token)
         (cons "oauth_version" "1.0")))
       (signature-string
        (twitter-signature-string "POST"
                                  "https://api.twitter.com/1.1/statuses/update.json"
                                  (append twitter-oauth-headers body)))
       (signature
        (org-sbe createSignature (signature_string (eval signature-string)) (key (eval signing-key)))))
    (message "%s" signature-string)
    (append twitter-oauth-headers (list (cons "oauth_signature"
                                              (url-hexify-string signature)))))
#+END_SRC

Now we need to build our HTTP headers for our request
#+NAME: twitter-restclient-headers
#+BEGIN_SRC elisp :var header=twitter-headers twitter-oauth-headers=twitter-oauth-headers
  (build-twitter-header-string header (sort twitter-oauth-headers
                                            (lambda (first second)
                                              (string< (car first) (car second)))))
#+END_SRC

We need to encode our body as a JSON string to work as a REST client
#+NAME: twitter-json-body
#+BEGIN_SRC elisp :var twitter-body=twitter-body-generated
  ;;(json-encode twitter-body)
  ;; (concat
  ;;  ""
  ;;  (mapconcat
  ;;   (lambda (entry)
  ;;     (concat (car entry) "=" (url-hexify-string (cdr entry))))
  ;;   twitter-body
  ;;   "&")
  ;;  "")
  (setq twitter-thing (concat
                       ""
                       (mapconcat
                        (lambda (entry)
                          (concat (car entry) "=" (url-hexify-string (cdr entry))))
                        twitter-body
                        "&")
                       ""))
twitter-thing
#+END_SRC

#+NAME: twitter-urlz
#+BEGIN_SRC elisp :var twitter-json-body=twitter-json-body
(concat "https://api.twitter.com/1.1/statuses/update.json?" twitter-json-body)
#+END_SRC

#+BEGIN_SRC restclient :var twitter-headers=twitter-restclient-headers twitter-body=twitter-json-body
  #
  :body := (concat twitter-thing)
  POST https://api.twitter.com/1.1/statuses/update.json?:body
  :twitter-headers
#+END_SRC

* References
1. https://developer.twitter.com/en/docs/basics/authentication/overview/application-only
2. https://cloud.google.com/vision/docs/request
3. https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/post-statuses-update.html
4. http://lti.tools/oauth/
