* Twitter has put me in a vegetative state
** Rest Call Me Maybe

The power and flexibility of Emacs, and its suite of packages, constantly amazes me. I've been a long time fan of `org-mode`. IMO it is great, in Emacs, replacement for Markdown and a number of other document formats. `org-mode` is a great place to practice [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate programming]], but it's also a great place to an interactive style of programming, like a REPL or a Jupyter Notebook.

Lately, I've spent a lot of time exploring web APIs. I've tried a couple of tools over the years: Postman — back when it was a chrome extension, Curl, and HTTTPie. They were all, ok — they got the job done — but they all ended up missing some feature or some UX. That's when I found [[https://github.com/pashky/restclient.el][restclient]], a package for Emacs with a simple `DSL` and could convert the restclient request to an equivalent `curl` request.

#+BEGIN_SRC restclient
  # Here we will post our base64 encoded secrets to get a bearer token
  POST https://api.twitter.com/oauth2/token
  Authorization: Basic QmRUTklkSEI5WWZHbVhwSkZ6NTZManpUNjpBMk1rOHJjaVdEWFdva3FCN1pmemZFdEk3WjRNd1lpM3JFSjhzN1JoVm9xMXhZY2pMbQ==
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=client_credentials
#+END_SRC

Then once, you've `POSTed` the request a new buffer opens up with the response.
#+NAME restclient response
#+begin_example
{
  "token_type": "bearer",
  "access_token": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}
// POST https://api.twitter.com/oauth2/token?grant_type=client_credentials
// HTTP/1.1 200 OK
// cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0
// content-disposition: attachment; filename=json.json
// content-length: 155
// content-type: application/json;charset=utf-8
// date: Thu, 24 Jan 2019 05:54:09 GMT
// expires: Tue, 31 Mar 1981 05:00:00 GMT
// last-modified: Thu, 24 Jan 2019 05:54:09 GMT
// ml: S
// pragma: no-cache
// server: tsa_a
// status: 200 OK
// strict-transport-security: max-age=631138519
// x-connection-hash: b93d89db0ee8f4ea90991c99c8d58449
// x-content-type-options: nosniff
// x-frame-options: DENY
// x-response-time: 20
// x-transaction: 005403e60014e9ee
// x-twitter-response-tags: BouncerCompliant
// x-ua-compatible: IE=edge,chrome=1
// x-xss-protection: 1; mode=block; report=https://twitter.com/i/xss_report
// Request duration: 0.079710s
#+end_example

Using [[https://www.youtube.com/watch?v=fTvQTMOGJaw][restclient]] as my primary means to play with APIs worked for me for quite awhile. It was a simple to read document, that housed all the requests in a single file, and lived alongside the rest of my code in `git`.

I eventually ran into three complications when using it however:
  1. My request files would become a mess and navigating to find a specific endpoint or a set of endpoints was a pain.
  2. I was lazy and dealing with authenticated APIs was a pain.
     - I'd need to enter my credentials each time I needed to get a new token
       - Once I authenticated, I would have to copy and paste that token from the response buffer into a variable, to use throughout the restclient file.
  3. For exploring APIs I like to take notes, record responses, and record the input.

There was a simple solution for my first and last points, which was to use [[https://www.youtube.com/watch?v=GK3fij-D1G8][org-mode]]. Org-mode has a [[https://orgmode.org/worg/org-contrib/babel/][babel]] extension for [[https://github.com/alf/ob-restclient.el][restclient]]. Babel is an extension that runs code contained in SRC block: `#+BEGIN_SRC...#+END_SRC` and saves any thing sent to STDOUT or value returned and then can be used in other SRC code blocks.

** Twitter
I think it's useful to see what I am talking about. So, let's see how we can use `org-mode` and `restclient` to authenticate with an `oauth` endpoint.
*** Helper functions
First we need to define a few functions that we are going to use during OAuth authentication. I could use a library or package for this, but I really hate myself so I want to spend an entire day debugging 403 errors.

#+BEGIN_EXAMPLE org
,#+BEGIN_SRC emacs-lisp
  (defun twitter-signing-key (consumer-secret token-secret)
    "Creates a signing key by combining the consumer-secret and the token secret and percent encoding the result"
    (concat
     (url-encode-url
      consumer-secret)
     "&"
     (url-encode-url
      token-secret)))

  (defun twitter-signature-string (method base params)
    "Builds a hex encoded string of the format METHOF&BASE&PARAM1=VALUE1..."
    (let ((sorted-params
           (sort params
                 (lambda (first second)
                   (string< (car first) (car second))))))
      (concat
       method
       "&"
       (url-hexify-string base)
       "&"
       (url-hexify-string
        (mapconcat
         (lambda (entry)
           (let ((key (car entry))
                 (value (cdr entry)))
             (concat (url-hexify-string key)
                     "="
                     (url-hexify-string value))))
         sorted-params
         "&")))))

  (defun build-twitter-header-string (header oauth-headers)
    "Takes in a list of cons cells that represent HTTP headers, as well as the information needed to define
     the OAUTH response for a Twitter request, and build a restclient style header string"
    (concat
     "<<\n"
     (mapconcat
      (lambda (entry)
        (let ((key (car entry))
              (value (cdr entry)))
          (concat
           key
           ": "
           value
           " ")))
      header
      "")
     "\nAuthorization: OAuth "
     (string-trim-right
      (mapconcat
       (lambda (entry)
         (let ((key (car entry))
               (value (cdr entry)))
           (concat
            key
            "="
            "\"" value "\""
            ",")))
       oauth-headers
       " ")
      ","))
    "#")
,#+END_SRC
#+END_EXAMPLE
*** Shhh It's a Secret
#+BEGIN_EXAMPLE org
#+NAME: twitter-consumer-key
,#+BEGIN_SRC bash
echo $TWITTER_CONSUMER_KEY
,#+END_SRC

#+NAME: twitter-consumer-secret
,#+BEGIN_SRC bash
echo $TWITTER_CONSUMER_SECRET
,#+END_SRC

#+NAME: twitter-access-token
,#+BEGIN_SRC bash
echo $TWITTER_ACCESS_TOKEN
,#+END_SRC

#+NAME: twitter-access-secret
,#+BEGIN_SRC bash
echo $TWITTER_ACCESS_SECRET
,#+END_SRC
#+END_EXAMPLE
I don't need to store the authentication information in files, and I don't need to rememeber them! I can just use the information that is stored in my environment.
*** Let's work on Auth
**** Step 1 Generate a body
Before we can do all of the fun authentication bits that is OAuth2, we need to have some content. So, I need to be on brand for an Emacs user and let everyone know I am using Emacs for a purpose that is explicitly not anything to do with text editing.

#+BEGIN_EXAMPLE org
#+NAME: hello-world
,#+BEGIN_SRC emacs-lisp
(setq twitter-body (list (cons "status" "Hello world! I'm tweeting from Emacs")))
,#+END_SRC
#+END_EXAMPLE
**** Step 2 Creating and Signing the Header
Ok, now that we have our twitter status, we need to autogenerate a few more pieces of information; a nonce, a timestamp, and the signature.

Emacs doesn't really have a built in crypto library, but do you know who does? Ruby! It's is a fun language with a pretty full featured STL, let's use it to generate our nonce.

#+BEGIN_EXAMPLE org
#+NAME: nonce
,#+BEGIN_SRC ruby
require 'securerandom'

nonce = SecureRandom.uuid
nonce.gsub(/\W/, "")
,#+END_SRC
#+END_EXAMPLE

Our request is going to need a time signature.
#+BEGIN_EXAMPLE org
#+NAME: oauth-time
,#+BEGIN_SRC emacs-lisp
  (format-time-string "%s")
,#+END_SRC
#+END_EXAMPLE

#+BEGIN_EXAMPLE org
We need to define the headers that we need for this request.
#+NAME: twitter-headers
,#+BEGIN_SRC emacs-lisp
(list
 (cons "Content-Type" "application/x-www-form-urlencoded"))
,#+END_SRC
#+END_EXAMPLE

Did I mention emacs built in cryptography is kind of lacking? Well, we'll need to let another language do the heavy lifting when signing the request. I like Node and Node has a decent crypto library built into it. In the example below I am defining a code block as a function that I am going to call later and use it in an emacs-lisp source block.
#+BEGIN_EXAMPLE org
#+NAME: createSignature
,#+BEGIN_SRC js :var signature_string="" :var key=""
  let crypto = require('crypto')

  let createSignature = (key, text) => {
    return crypto.createHmac('sha1', key).update(signature_string).digest('binary');
  }

  return createSignature(key, signature_string).toString('base64');
,#+END_SRC
#+END_EXAMPLE

Now before we can sign anything, and we *do* need to sign things, we need to create a signing key. We can use our consumer-secret and our access-secret we can build a twitter signing key.
#+BEGIN_EXAMPLE org
#+NAME: signing-key
,#+BEGIN_SRC emacs-lisp :var consumer-secret=twitter-consumer-secret token-secret=twitter-access-secret
  (twitter-signing-key consumer-secret token-secret)
,#+END_SRC
#+END_EXAMPLE

Next up, we need to build the header, create a string to sign, sign that string and them add that signature to our header. Simple.
#+BEGIN_EXAMPLE org
#+NAME: twitter-oauth-headers
,#+BEGIN_SRC emacs-lisp :var nonce=nonce consumer-key=twitter-consumer-key access-token=twitter-access-token oauth-time=oauth-time body=twitter-body signing-key=signing-key
  (let*
      ((twitter-oauth-headers
        (list
         (cons "oauth_consumer_key" consumer-key)
         (cons "oauth_nonce" nonce)
         (cons "oauth_signature_method" "HMAC-SHA1")
         (cons "oauth_timestamp" oauth-time)
         (cons "oauth_token" access-token)
         (cons "oauth_version" "1.0")))
       (signature-string
        (twitter-signature-string "POST"
                                  "https://api.twitter.com/1.1/statuses/update.json"
                                  (append twitter-oauth-headers twitter-body)))
       (signature
        (org-sbe createSignature (signature_string (eval signature-string)) (key (eval signing-key)))))
    (append twitter-oauth-headers (list (cons "oauth_signature"
                                              (url-hexify-string signature)))))
,#+END_SRC
#+END_EXAMPLE

*** Step 3: Posting To Twitter
Up next, our headers need to be in a string format that our `restclient` knows how to read.
#+BEGIN_EXAMPLE org
#+NAME: twitter-restclient-headers
,#+BEGIN_SRC emacs-lisp :var header=twitter-headers twitter-oauth-headers=twitter-oauth-headers
  (build-twitter-header-string header (sort twitter-oauth-headers
                                            (lambda (first second)
                                              (string< (car first) (car second)))))
,#+END_SRC
#+END_EXAMPLE

We need to encode our body as a post parameter string to work as a REST client.
#+BEGIN_EXAMPLE org
#+NAME: twitter-post-body
,#+BEGIN_SRC emacs-lisp :var twitter-body=hello-world
  (setq twitter-json-body
        (concat
         ""
         (mapconcat
          (lambda (entry)
            (concat (car entry) "=" (url-hexify-string (cdr entry))))
          twitter-body
          "&")
         ""))
,#+END_SRC
#+END_EXAMPLE

Finally, we take all that work we've done signing things and telling the world how much we like Emacs, let's end this:
#+BEGIN_EXAMPLE org
,#+BEGIN_SRC restclient :var twitter-headers=twitter-restclient-headers twitter-body=twitter-json-body
  #
  :body := (concat twitter-json-body)
  POST https://api.twitter.com/1.1/statuses/update.json?:body
  :twitter-headers
,#+END_SRC
#+END_EXAMPLE

** To 11

[[./images/to_11.gif]]

Now that we've seen the basic process for using `restclient` in an interactive literate programming style. Let's see how much further we can take things.

*** More Helper Functions
We need a function to sanitize the response we get from restclient
#+BEGIN_SRC emacs-lisp
(defun sanitize-restclient-response (string)
 (string-trim (replace-regexp-in-string "^#\\+BEGIN_SRC js\\|^#\\+END_SRC\\|^//[[:print:]]+" "" string)))
#+END_SRC

Here's a couple of functions we're going to use to help us parse a response from Google's API.
#+BEGIN_SRC emacs-lisp
  (defun parse-ml-response (responses)
    "Extracts A Google AI response down to a list of label annotations"
    (let* ((json-response (json-read-from-string responses))
           (label-annotations  (cdr
                               (assoc 'labelAnnotations
                                      (elt
                                       (cdr (assoc 'responses json-response))
                                       0)))))
      label-annotations))

  (defun contains-description-p (annotations descriptions)
    "Checks to see if any of the items in the sequence ANNOTATIONS has a description that matches one of the items in DESCRIPTIONS"
    (let ((annotated-descriptions (mapcar (lambda (item) (cdr (assoc 'description item))) annotations)))
      (reduce (lambda (predicate description)
                (if predicate
                    predicate
                  (if (member description descriptions)
                      't
                    nil)))
              annotated-descriptions
              :initial-value nil)))
#+END_SRC
*** Demo
**** Harvesting a name
Let's give our source block a name, `#+NAME: trefle`, so we can easily reference it throughout the rest of our notebook. I am using my Mac's keychain to store and retrieve an access token I have stored for trefle.io.
#+NAME: trefle
#+BEGIN_SRC bash :results output
  security find-generic-password -gws trefle.io
#+END_SRC

To import a variable from earlier in the file you can use `:var token=trefle` where :var token, specified that you what to insert a variable called token into the proceeding block and the contents of that variable a pull from a block by the name of `trefle`. Now we just need to build the HTTP headers we're going to use for our interaction with trefle.
#+NAME: trefle-headers
#+BEGIN_SRC emacs-lisp :var token=trefle
  (concat
     "<<
  Content-Type: application/json
  Accept: application/json
  Authorization: Bearer " token)
#+END_SRC

As of the last time I looked, trefle.io has over 4000 pages of plants, so we want to get a random plant off of a random page. So to start, we'll generate a page number from 0 to 4000...
#+NAME: plants
#+BEGIN_SRC restclient :var headers=trefle-headers  :results value drawer
  #
  :page := (random 4000)
  GET https://trefle.io/api/plants?page=:page
  :headers
  #
#+END_SRC

Before we can do anything with the output we need to clean it up, restclient likes to have all the headers for the response at the bottom of the buffer, so we need to filter those out of the response.
#+NAME: sanitized-response
#+BEGIN_SRC emacs-lisp :var response=plants
(sanitize-restclient-response response)
#+END_SRC

Now we could use emacs-lisp, but everyone has NodeJS installed and NodeJS is pretty much built for parsing JSON, so it only makes sense to use that. We'll grab a random plant from the results and return its name.
#+NAME: plant-name
#+BEGIN_SRC js :var plants=sanitized-response :results value drawer
  let index = Math.floor(Math.random() * 30);
  return JSON.parse(plants)[index].scientific_name;
#+END_SRC

**** Imagine
I need to get my Google API key, for this I've been lazy and have just been storing it in my environment.
#+NAME: google-api-key
#+BEGIN_SRC bash
  echo $GOOGLE_API_KEY
#+END_SRC

We've got a plant name, now we need image of the plant.
#+NAME: google-images
#+BEGIN_SRC restclient :var api-key=google-api-key plant-name=plant-name
  GET https://content.googleapis.com/customsearch/v1?cx=009341007550343915479%3Afg_hsgzltxw&q=:plant-name&searchType=image&key=:api-key
#+END_SRC

Much like our search for a plant name, we need to clean up the response from google API so it's easily parsable as JSON.
#+NAME: flower-images
#+BEGIN_SRC emacs-lisp :var google-images=google-images
  (sanitize-restclient-response google-images)
#+END_SRC

We have a nice list of plant images, let's play google roulette and use the first image from the search.
#+NAME: plant-image
#+BEGIN_SRC js :var plant_images=flower-images :results value drawer
  return "" + JSON.parse(plant_images).items[0].link
#+END_SRC

**** What will we learn today?
[[./images/PreciousHoarseFieldspaniel.gif]]

But how can we be sure to trust Google? When we're running our code don't have time to make sure all it does what it is actually supposed to do. Instead, we'll use Machine Learning provided by the fabulous Google to ensure our image is what we expect it to be. We'll ask google for the top 3 labels it has given that image and if it contains a plant like word we'll use it later on.
#+NAME: plant-ml-results
#+BEGIN_SRC restclient :var api-key=google-api-key plant-image=plant-image
  POST https://vision.googleapis.com/v1/images:annotate?key=:api-key
  {
    "requests":[
      {
        "image":{
          "source":{
            "imageUri":
            :plant-image
          }
        },
        "features":[
          {
            "type":"LABEL_DETECTION",
            "maxResults":3
          }
        ]
      }
    ]
  }
#+END_SRC

[[./images/clean_things.png]]
#+NAME: sanitized-ml-results
#+BEGIN_SRC emacs-lisp :var response=plant-ml-results
(sanitize-restclient-response response)
#+END_SRC

If you're curious what talking to the Google Vision api looks like...
#+NAME: google-vision-response
#+begin_example json
{
  "responses": [
    {
      "labelAnnotations": [
        {
          "mid": "/m/04_tb",
          "description": "map",
          "score": 0.9684097,
          "topicality": 0.9684097
        },
        {
          "mid": "/m/03scnj",
          "description": "line",
          "score": 0.734654,
          "topicality": 0.734654
        },
        {
          "mid": "/m/07j7r",
          "description": "tree",
          "score": 0.7276011,
          "topicality": 0.7276011
        }
      ]
    }
  ]
}
#+end_example

Let's check to see if the first three descriptors come back as plant, tree, or a flower:
#+NAME: image-is-plant-p
#+BEGIN_SRC emacs-lisp :var response=sanitized-ml-results
  (contains-description-p
   (parse-ml-response response)
   '("plant" "tree" "flower"))
#+END_SRC
***** TODO Add section check for predicate returning true
In this section we will show how to use them result from image-is-plant-p, to check if the image is of a plant like thing and if not rerun the source blocks until we geta result that we expect.

**** A rose by any other name
We need one last piece of information before we can demonstrate our love of Plants to the world, someone to tweet at. Let's ask ourselves for some input.
#+NAME: twitter-handle
#+BEGIN_SRC emacs-lisp
(read-string "What is the twitter handle of someone you want to tweet? ")
#+END_SRC

**** Content is king
Now we need to build our body into something we can process later together...
#+NAME: twitter-body
#+BEGIN_SRC emacs-lisp :var plant_name=plant-name plant_image=plant-image twitter_handle=twitter-handle
  (setq twitter-body
   (list
    (cons "status" (concat "" twitter_handle " " plant_name " " (replace-regexp-in-string "'" "" plant_image)))))
#+END_SRC
**** TODO Rerun
In this section we copy and paste most of the code we've written for doing all the fun twitter stuff in the second section and use it to post the new content
* References
1. https://developer.twitter.com/en/docs/basics/authentication/overview/application-only
2. https://cloud.google.com/vision/docs/request
3. https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/post-statuses-update.html
4. http://lti.tools/oauth/
