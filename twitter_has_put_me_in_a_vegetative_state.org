* Twitter has put me in a vegetative state
** Rest Call Me Maybe

The power and flexibility that Emacs, and it's suite of packages, constantly amazes me. I've been a big fan of `org-mode` for a long time, it's a great in Emacs replacement for Markdown and a number of other document formats, thanks to pandoc. `org-mode` is a great place to practice [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate programming]], but it's also a great place to an interactive style of programming, like a REPL or a Jupyter Notebook.

Lately, I've spent a lot of time exploring web APIs. I've tried a several tools over the years: Postman â€” back when it was a chrome extension, Curl, and HTTTPie. They were all, all right to get the job done, but they all ended up missing some feature or some UX. That's when I found [[https://github.com/pashky/restclient.el][restclient]], a package for Emacs with a simple `DSL` and could convert the restclient request to an equivalent `curl` request.

#+BEGIN_SRC restclient
  # Here we will post our base64 encoded secrets to get a bearer token
  POST https://api.twitter.com/oauth2/token
  Authorization: Basic QmRUTklkSEI5WWZHbVhwSkZ6NTZManpUNjpBMk1rOHJjaVdEWFdva3FCN1pmemZFdEk3WjRNd1lpM3JFSjhzN1JoVm9xMXhZY2pMbQ==
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=client_credentials
#+END_SRC

Then once, you've `POSTed` the request a new buffer opens up with the response.
#+NAME restclient response
#+begin_example
{
  "token_type": "bearer",
  "access_token": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}
// POST https://api.twitter.com/oauth2/token?grant_type=client_credentials
// HTTP/1.1 200 OK
// cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0
// content-disposition: attachment; filename=json.json
// content-length: 155
// content-type: application/json;charset=utf-8
// date: Thu, 24 Jan 2019 05:54:09 GMT
// expires: Tue, 31 Mar 1981 05:00:00 GMT
// last-modified: Thu, 24 Jan 2019 05:54:09 GMT
// ml: S
// pragma: no-cache
// server: tsa_a
// status: 200 OK
// strict-transport-security: max-age=631138519
// x-connection-hash: b93d89db0ee8f4ea90991c99c8d58449
// x-content-type-options: nosniff
// x-frame-options: DENY
// x-response-time: 20
// x-transaction: 005403e60014e9ee
// x-twitter-response-tags: BouncerCompliant
// x-ua-compatible: IE=edge,chrome=1
// x-xss-protection: 1; mode=block; report=https://twitter.com/i/xss_report
// Request duration: 0.079710s
#+end_example

Using [[https://www.youtube.com/watch?v=fTvQTMOGJaw][restclient]] as my primary means to play with APIs worked for me for quite awhile. It was a simple to read document, that housed all the requests in a single file, and lived alongside the rest of my code in `git`.

I eventually ran into three complications when using it however:
  1. My request files would get to big and navigating around to find a specific endpoint or a set of endpoints would be a pain.
  2. I was lazy and dealing with authenticated APIs was a pain.
     - I'd need to enter my credentials each time I needed to get a new token
     - Once I authenticated I would have to copy and paste that token from the response buffer into a variable in my restclient file
  3. For exploring APIs I like to take notes, record responses and record the data I would put into them.

There was a simple solution for my first and last points, which was to use [[https://www.youtube.com/watch?v=GK3fij-D1G8][org-mode]]. Org-mode has a [[https://orgmode.org/worg/org-contrib/babel/][babel]] extension for [[https://github.com/alf/ob-restclient.el][restclient]], making it easy for me to write in a more literate style.

** Twitter
I think it's useful to see what I am talking about, let's see how we can use `org-mode` and `restclient` can make authenticating with an `oauth` endpoint.
*** Helper functions
First we need to define a few functions that will sign the request and build a string that the restclient can use.
#+BEGIN_SRC elisp
  (defun twitter-signing-key (consumer-secret token-secret)
    "Creates a signing key by combining the consumer-secret and the token secret and percent encoding the result"
    (concat
     (url-encode-url
      consumer-secret)
     "&"
     (url-encode-url
      token-secret)))

  (defun twitter-signature-string (method base params)
    (let ((sorted-params
           (sort params
                 (lambda (first second)
                   (string< (car first) (car second))))))
      (concat
       method
       "&"
       (url-hexify-string base)
       "&"
       (url-hexify-string
        (mapconcat
         (lambda (entry)
           (let ((key (car entry))
                 (value (cdr entry)))
             (concat (url-hexify-string key)
                     "="
                     (url-hexify-string value))))
         sorted-params
         "&")))))

  (defun build-twitter-header-string (header oauth-headers)
    "Takes in a list of cons cells that represent HTTP headers, as well as the information needed to define the OAUTH response for a Twitter request, and build a restclient style header string"
    (concat
     "<<\n"
     (mapconcat
      (lambda (entry)
        (let ((key (car entry))
              (value (cdr entry)))
          (concat
           key
           ": "
           value
           " ")))
      header
      "")
     "\nAuthorization: OAuth "
     (string-trim-right
      (mapconcat
       (lambda (entry)
         (let ((key (car entry))
               (value (cdr entry)))
           (concat
            key
            "="
            "\"" value "\""
            ",")))
       oauth-headers
       " ")
      ",")))
#+END_SRC

*** Shhh it's Secret
I don't need to store the authentication information in files, and I don't need to rememebr them! I can just use the tokens that stored in my env vars.
#+NAME: twitter-consumer-key
#+BEGIN_SRC sh
echo $TWITTER_CONSUMER_KEY
#+END_SRC

#+NAME: twitter-consumer-secret
#+BEGIN_SRC sh
echo $TWITTER_CONSUMER_SECRET
#+END_SRC

#+NAME: twitter-access-token
#+BEGIN_SRC sh
echo $TWITTER_ACCESS_TOKEN
#+END_SRC

#+NAME: twitter-access-secret
#+BEGIN_SRC sh
echo $TWITTER_ACCESS_SECRET
#+END_SRC

*** Functions stuff
**** Let's work on Auth
***** Step 0 Generate a body
Can do all of the fun authentication bits that is OAuth2, we need to have some content. So, I need to be on brand for an Emacs user and let everyone know I am using Emacs for a purpose that is explicitly not anything to do with text editing.

#+NAME: hello-world
#+BEGIN_SRC elisp
(setq twitter-body '"Hello world! I'm tweeting from Emacs")
#+END_SRC

***** Step 1 Header creation and Signing the Header
Ok, now that we have our twitter status, we need to autogenerate a few more pieces of information; a nonce, a none a timestamp and the signature.

Emacs's doesn't really have a built in crypto library, but do you know who does? Ruby! It's is a fun language with a pretty full featured STL, let's use it to generate our Nonce.
#+NAME: nonce
#+BEGIN_SRC ruby
require 'securerandom'

nonce = SecureRandom.uuid
nonce.gsub(/\W/, "")
#+END_SRC

Our request is going to need a time signature.
#+NAME: oauth-time
#+BEGIN_SRC elisp
  (format-time-string "%s")
#+END_SRC

We need to define the headers that we need for this request.
#+NAME: twitter-headers
#+BEGIN_SRC elisp
(list
 (cons "Content-Type" "application/x-www-form-urlencoded"))
#+END_SRC

Did I mention emacs built in cryptography is kind of lacking? Well, we'll need to let another language do the heavy lifting. I like Node and Node has a decent crypto library built into it. In the example below I am defining a code block as a function that I am going to call later and use it in an emacs-lisp source block.
#+NAME: createSignature
#+BEGIN_SRC js :var signature_string="" :var key=""
  let crypto = require('crypto')

  let createSignature = (key, text) => {
    return crypto.createHmac('sha1', key).update(signature_string).digest('binary');
  }

  return createSignature(key, signature_string).toString('base64');
#+END_SRC


Now before we can sign anything, and as an FYI in the next block we need to sign things, we need to create a signing key. By using our consumer-secret and our access-secret.
#+NAME: signing-key
#+BEGIN_SRC elisp :var consumer-secret=twitter-consumer-secret token-secret=twitter-access-secret
  (twitter-signing-key consumer-secret token-secret)
#+END_SRC

Next up, we need to build the header, create a string to sign, sign that string and them add that signature to our header. Simple.
#+NAME: twitter-oauth-headers
#+BEGIN_SRC elisp :var nonce=nonce consumer-key=twitter-consumer-key access-token=twitter-access-token oauth-time=oauth-time body=twitter-body- signing-key=signing-key
  (let*
      ((twitter-oauth-headers
        (list
         (cons "oauth_consumer_key" consumer-key)
         (cons "oauth_nonce" nonce)
         (cons "oauth_signature_method" "HMAC-SHA1")
         (cons "oauth_timestamp" oauth-time)
         (cons "oauth_token" access-token)
         (cons "oauth_version" "1.0")))
       (signature-string
        (twitter-signature-string "POST"
                                  "https://api.twitter.com/1.1/statuses/update.json"
                                  (append twitter-oauth-headers twitter-body)))
       (signature
        (org-sbe createSignature (signature_string (eval signature-string)) (key (eval signing-key)))))
    (append twitter-oauth-headers (list (cons "oauth_signature"
                                              (url-hexify-string signature)))))
#+END_SRC

Up next, our headers need to be in a string format that our `restclient` knows how to read.
#+NAME: twitter-restclient-headers
#+BEGIN_SRC elisp :var header=twitter-headers twitter-oauth-headers=twitter-oauth-headers
  (build-twitter-header-string header (sort twitter-oauth-headers
                                            (lambda (first second)
                                              (string< (car first) (car second)))))
#+END_SRC

We need to encode our body as a post parameter string to work as a REST client.
#+NAME: twitter-post-body
#+BEGIN_SRC elisp :var twitter-body=twitter-body-generated
  (setq twitter-json-body
        (concat
         ""
         (mapconcat
          (lambda (entry)
            (concat (car entry) "=" (url-hexify-string (cdr entry))))
          twitter-body
          "&")
         ""))
  twitter-thing
#+END_SRC

Finally, we take all that work we've done signing things and telling the world how much we like Emacs, let's end this:
#+BEGIN_SRC restclient :var twitter-headers=twitter-restclient-headers twitter-body=twitter-json-body
  #
  :body := (concat twitter-json-body)
  POST https://api.twitter.com/1.1/statuses/update.json?:body
  :twitter-headers
#+END_SRC

** Setup
We need a function to sanitize the response we get from restclient
#+BEGIN_SRC elisp
(defun sanitize-restclient-response (string)
 (string-trim (replace-regexp-in-string "^#\\+BEGIN_SRC js\\|^#\\+END_SRC\\|^//[[:print:]]+" "" string)))
#+END_SRC

Here's a couple of functions we're going to use to help us parse a response from Google's API.
#+BEGIN_SRC elisp
  (defun parse-ml-response (responses)
    "Extracts A Google AI response down to a list of label annotations"
    (let* ((json-response (json-read-from-string responses))
           (label-annotations  (cdr
                               (assoc 'labelAnnotations
                                      (elt
                                       (cdr (assoc 'responses json-response))
                                       0)))))
      label-annotations))

  (defun contains-description-p (annotations descriptions)
    "Checks to see if any of the items in the sequence ANNOTATIONS has a description that matches one of the items in DESCRIPTIONS"
    (let ((annotated-descriptions (mapcar (lambda (item) (cdr (assoc 'description item))) annotations)))
      (reduce (lambda (predicate description)
                (if predicate
                    predicate
                  (if (member description descriptions)
                      't
                    nil)))
              annotated-descriptions
              :initial-value nil)))
#+END_SRC

Finally we're going to want some code to run a specific source code block
#+BEGIN_SRC elisp

#+END_SRC

** Preamble
I really like plants, and I love to learn random plant facts. So I am going to use [[https://trefle.io/reference][trefle.io]] API to tweet out facts about random plants.
** Demo
Let's give our source block a name, `#+NAME: trefle`, so we can easily reference it throughout the rest of our notebook. I am using my Mac's keychain to store and retrieve an access token I have stored for trefle.io.
#+NAME: trefle
#+BEGIN_SRC bash :results output
  security find-generic-password -gws trefle.io
#+END_SRC

To import a variable from earlier in the file you can use `:var token=trefle` where :var token, specified that you what to insert a variable called token into the proceeding block and the contents of that variable a pull from a block by the name of `trefle`. Now we just need to build the HTTP headers we're going to use for our interaction with trefle.
#+NAME: trefle-headers
#+BEGIN_SRC elisp :var token=trefle
  (concat
     "<<
  Content-Type: application/json
  Accept: application/json
  Authorization: Bearer " token)
#+END_SRC

As of the last time I looked, trefle.io has over 4000 pages of plants, so we want to get a random plant off of a random page. So to start, we'll generate a page number from 0 to 4000...
#+NAME: plants
#+BEGIN_SRC restclient :var headers=trefle-headers  :results value drawer
  #
  :page := (random 4000)
  GET https://trefle.io/api/plants?page=:page
  :headers
  #
#+END_SRC

Before we can do anything with the output we need to clean it up, restclient likes to have all the headers for the response at the bottom of the buffer, so we need to filter those out of the response.
#+NAME: sanitized-response
#+BEGIN_SRC elisp :var response=plants
(sanitize-restclient-response response)
#+END_SRC

Now we could use elisp, but everyone has NodeJS installed and NodeJS is pretty much built for parsing JSON, so it only makes sense to use that. So we'll grab a random plant from the sanitized results and return it's ID.

#+NAME: plant-name
#+BEGIN_SRC js :var plants=sanitized-response :results value drawer
  let index = Math.floor(Math.random() * 30);
  return JSON.parse(plants)[index].scientific_name;
#+END_SRC

Now, I need to get my Google API key, for this I've been lazy and have just been storing it as an ENV var.
#+NAME: google-api-key
#+BEGIN_SRC bash
  echo $GOOGLE_API_KEY
#+END_SRC

Now that we've got a plant name, let's get an image to use to give an example of the plant.

#+NAME: google-images
#+BEGIN_SRC restclient :var api-key=google-api-key plant-name=plant-name
  GET https://content.googleapis.com/customsearch/v1?cx=009341007550343915479%3Afg_hsgzltxw&q=:plant-name&searchType=image&key=:api-key
#+END_SRC

Now much like our search for a plant name, we need to clean up the response from google API so it's easily parsable as JSON.
#+NAME: flower-images
#+BEGIN_SRC elisp :var google-images=google-images
  (sanitize-restclient-response google-images)
#+END_SRC

Now that we have a nice list of plants, let's play google roulette and use the first image from the search.

#+NAME: plant-image
#+BEGIN_SRC js :var plant_images=flower-images :results value drawer
  return "" + JSON.parse(plant_images).items[0].link
#+END_SRC

But how can we be sure to trust Google? We don't have time to make sure all of our code does what it is actually supposed to do. In stead, we'll use Machine Learning provided by the fabulous Google to ensure our image is what we expect it to be.
#+NAME: plant-ml-results
#+BEGIN_SRC restclient :var api-key=google-api-key plant-image=plant-image
POST https://vision.googleapis.com/v1/images:annotate?key=:api-key
{
  "requests":[
    {
      "image":{
        "source":{
          "imageUri":
           :plant-image
        }
      },
      "features":[
        {
          "type":"LABEL_DETECTION",
          "maxResults":3
        }
      ]
    }
  ]
  }
#+END_SRC

Again some data clean up
#+NAME: sanitized-ml-results
#+BEGIN_SRC elisp :var response=plant-ml-results
(sanitize-restclient-response response)
#+END_SRC

#+NAME: sanitized-ml-results
#+begin_example
{
  "responses": [
    {
      "labelAnnotations": [
        {
          "mid": "/m/04_tb",
          "description": "map",
          "score": 0.9684097,
          "topicality": 0.9684097
        },
        {
          "mid": "/m/03scnj",
          "description": "line",
          "score": 0.734654,
          "topicality": 0.734654
        },
        {
          "mid": "/m/07j7r",
          "description": "tree",
          "score": 0.7276011,
          "topicality": 0.7276011
        }
      ]
    }
  ]
}
#+end_example

Let's check to see if the first three descriptors come back as plant, tree, or a flower
#+NAME: image-is-plant-p
#+BEGIN_SRC elisp :var response=sanitized-ml-results
  (contains-description-p
   (parse-ml-response response)
   '("plant" "tree" "flower"))
#+END_SRC

We need one last piece of information before we can demonstrate our love of Plants to the world, someone to tweet at. Let's ask ourselves for some input.
#+NAME: twitter-handle
#+BEGIN_SRC elisp
(read-string "What is the twitter handle of someone you want to tweet? ")
#+END_SRC

# First we'll need to do some prep work before we can authenticate with twitter. In [[https://developer.twitter.com/en/docs/basics/authentication/overview/application-only#step-1-encode-consumer-key-and-secret][Step 1]] of the Twitter tutorial for authentication, we need to encode our tokens according to RFC 1738, join them with a colon, and then base64 encode the result. In the snippet below we're going to use an elisp function that follows RFC 1738, so we don't have to do it manually.

** Twitter Stuff
*** Let's generating content
#+NAME: twitter-body
#+BEGIN_SRC elisp :var plant_name=plant-name plant_image=plant-image twitter_handle=twitter-handle
  (setq twitter-body
   (list
    (cons "status" (concat "" twitter_handle " " plant_name " " (replace-regexp-in-string "'" "" plant_image)))))
#+END_SRC

#+NAME: twitter-body-generated
#+BEGIN_SRC elisp
 (list (cons "status" "@spiralganglion 'Lathyrus laetivirens' https://www.pacificbulbsociety.org/pbswiki/files/Alpinia/Alpinia_carolinensis1NN.jpg"))
#+END_SRC

* References
1. https://developer.twitter.com/en/docs/basics/authentication/overview/application-only
2. https://cloud.google.com/vision/docs/request
3. https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/post-statuses-update.html
4. http://lti.tools/oauth/
