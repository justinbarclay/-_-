* Outline

When last we left our heroes, they were in the deep woods of Emacs. After hacking at a few goblins, all named Slack, our heroes must now decide where they must go next...

What shall our heroes do?

#+BEGIN_SRC web
  // Notes to self this is just an rough outline of what I want. I am going to have to program this myself.

  <div>
      <input type="radio" id="fight"
             name="quest" value="fight">
      <label for="contactChoice1">Fight the evil wizard Vim</label>

      <input type="radio" id="clean"
             name="quest" value="clean">
      <label for="contactChoice2">Clean up</label>
  </div>
  <script>
   document.addEventListener('click',
                             function(event){
                                 $.selectElement('questChoice').value('clean_up');
                             });
  </script>
#+END_SRC

Before I reveal your choice to you I want to quickly show you ~slack-select-room~ which can be found in [[https://github.com/yuya373/emacs-slack/blob/master/slack-room.el#L256][slack-room.el]]
#+BEGIN_SRC emacs-lisp
(defun slack-select-rooms ()
  (interactive)
  (let* ((team (slack-team-select))
         (room (slack-room-select
                (cl-loop for team in (list team)
                         append (with-slots (groups ims channels) team
                                  (append ims groups channels))))))
    (slack-room-display room team)))
#+END_SRC

~slack-select-room~ is a lot like code I had previously used to choose where to post my message, ~slack-select-channel~, but this allows us to post in any slack room: channels, ims, and groups.

** Back to our regularly scheduled program
You have chosen "clean up"! A brave choice indeed!

** Previously on the X-Files...
[[./images/x-files-mulder-scully.jpg]]

I had figured out how to share any region of a buffer in Emacs and send it to Slack with it decorated as code.
#+BEGIN_SRC emacs-lisp tangle
  (defun jb/send-region-to-slack-code ()
    (interactive)
    (let* ((team (slack-team-select))  ;; Get all rooms from selected team
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (concat "```" (filter-buffer-substring (region-beginning) (region-end)) "```")
                                   (oref room id)
                                   team)))
#+END_SRC

Unfortunately, that isn't enough for me! I don't always want to demarcate text as code, sometimes I just want to send naked text.

#+BEGIN_SRC emacs-lisp
(defun jb/send-region-to-slack ()
  (interactive)
  (let ((team (slack-team-select)) ;; Select team
        (room (slack-room-select
               (cl-loop for team in (list team)
                        for channels = (oref team channels)
                        nconc channels)))) ;; Get all rooms from selected team
    (slack-message-send-internal (filter-buffer-substring (region-beginning) (region-end))
                                 (oref room id)
                                 team)))
#+END_SRC

Or I want to have my text dress-up and be all snappy in quotes!
#+BEGIN_SRC emacs-lisp
  (defun jb/send-region-to-slack-code ()
    (interactive)
    (let* ((team (slack-team-select))  ;; Get all rooms from selected team
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (concat "> " (filter-buffer-substring (region-beginning) (region-end)))
                                   (oref room id)
                                   team)))
#+END_SRC

[[./images/its_not_working.gif]]

** Wait A Minute
[[./images/why_isnt_it_working.gif]]

Apparently in Markdown's [[https://daringfireball.net/projects/markdown/syntax#blockquote][inifinite wisdom]], they made it so that each line of text you want to quote has to be preceeded by "> ".

** Houston We Have A Problem
I've run into a big problem. I don't know how to iterate through text in a buffer.

Iterating through a list of strings is easy, after all this is lisp, the language is meant for processing lists! Below, all I had to do was [[https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html][mapcar]] over a list of strings and concat "> " to the beginning of each item.

#+BEGIN_SRC emacs-lisp
  (setq quotes '("I hope he didn’t die. Unless he left a note naming me his successor, then I hope he did die."
                    "I’m so embarrassed. I wish everybody else was dead."
                    "Have you ever tried simply turning off your TV, sitting down with your child, and hitting them?"))

  (mapcar (lambda (line) (concat "> " line)) quotes)
#+END_SRC

#+RESULTS:
| > I hope he didn’t die. Unless he left a note naming me his successor, then I hope he did die.    |
| > I’m so embarrassed. I wish everybody else was dead.                                             |
| > Have you ever tried simply turning off your TV, sitting down with your child, and hitting them? |

But if we step this up a notch, we get an error letting us know that we are not doing what we think we are doing.
#+BEGIN_SRC emacs-lisp
  (defun quote-region ()
    (interactive)
    (message (mapcar (lambda (line) (concat "> " line)) (filter-buffer-substring (region-beginning) (region-end)))))
#+END_SRC

#+RESULTS:
| Wrong type argument: sequencep, 40 |

** Oddity
[[./images/BowieSpaceOddity.jpg]]

No not a space oddity

#+BEGIN_SRC emacs-lisp
  (defun quote-region ()
    (interactive)
    (message
     (mapcar (lambda (line) (concat "> " line))
             (split-string
              (filter-buffer-substring (region-beginning) (region-end))
              "\n"
              t))))
#+END_SRC

#+RESULTS:
| Wrong type argument: stringp, (#("> Hello" 2 7 (fontified t font-lock-fontified t help-echo nil src-block t ws-butler-chg chg ...)) #("> World" 2 7 (fontified t font-lock-fontified t help-echo nil src-block t ws-butler-chg chg ...))) |

** Everything is wet!
If you look at this code it's very repetitive and I feel like a lot of it can be DRY'd up.

Rather then having a different function for each decoration, I can take advantage of [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][Emacs completion framework]].

#+BEGIN_SRC emacs-lisp
  (setq-local decorators '(("None" . (lambda (text) text))
                           ("Code"  . (lambda (text) (concat "```" text "```")))
                           ("Quote"  . (lambda (text) text))))

    (defun decorate-text ()
      (interactive)
      (let ((decoration (completing-read "Select decoration: "
                                         decorators
                                         nil[[BowieSpaceOddity.jpg]
                                         t)))
        (message (funcall (cdr (./images/assoc decoration decorators)) "Oh yeah"))))]
#+END_SRC

Now that we've got the easy part done, let's move onto the harder part in Emacs, programatically manipulating text.

Inspiration:
http://ergoemacs.org/emacs/elisp_process_lines.html
https://emacs.stackexchange.com/a/2193
https://www.gnu.org/software/emacs/manual/html_node/elisp/Current-Buffer.html

#+BEGIN_SRC emacs-lisp
  (defun jb/slack-quote-region (region)
    (with-temp-buffer
      (insert region)
      (goto-char 1) ;; Go to beginning of temporary buffer
      (while (> (point-max) (point)) ;; point is where cursor is in buffer, point-max is last position in buffer
        (beginning-of-line) ;; Always make sure we're at the beginning of the line
        (insert "> ") ;; Insert at point
        (forward-line 1)) ;; Go to next line
      (buffer-string))) ;; Return contents of temp buffer
#+END_SRC

So now this means we can update our decorators

#+BEGIN_SRC emacs-lisp
(setq-local decorators '(("None" . (lambda (text) text)) ;; The identity function
                         ("Code"  . (lambda (text) (concat "```" text "```")))
                         ("Quote"  . (lambda (text) (jb/slack-quote-region text))))
#+END_SRC

** Bringing it all together
We've searched through the puzzle box and found all the pieces. Let's put them together
#+BEGIN_SRC emacs-lisp
  (defun jb/slack-quote-region (region)
      (with-temp-buffer
        (insert region)
        (goto-char 1)
        (while (> (point-max) (point))
          (beginning-of-line)
          (insert "> ")
          (forward-line 1))
        (buffer-string)))

  (defun jb/decorate-text (text)
    (let* ((decorators '(("None" . (lambda (text) text))
                         ("Code"  . (lambda (text) (concat "```" text "```")))
                         ("Quote"  . (lambda (text) (jb/slack-quote-region text)))))
           (decoration (completing-read "Select decoration: "
                                        decorators
                                        nil
                                        t)))
      (funcall (cdr (assoc decoration decorators)) text)))


  (defun jb/send-region-to-slack ()
    (interactive)
    (let* ((team (slack-team-select))
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (jb/decorate-text (filter-buffer-substring (region-beginning) (region-end)))
                                   (oref room id)
                                   team)))
#+END_SRC

This is perfect, thanks to the updates I've covered here, my code base is smaller, more powerful, and I think in a state I can make a pull request out of it.
** Let's clean this up
*** make it more generic, not just channels, but any type of room!
*** Markdown that markup!
*** DRY IT UP!
