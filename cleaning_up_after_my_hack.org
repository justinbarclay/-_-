* Outline

When last we left our heroes, they were in the deep woods of Emacs. After hacking at a few goblins, all named Slack, our heroes must now decide where they must go next...

What shall our heroes do?

#+BEGIN_SRC web
  // Notes to self this is just a rough outline of what I want. I am going to have to program this myself.

  <div>
      <input type="radio" id="fight"
             name="quest" value="fight">
      <label for="contactChoice1">Fight the evil wizard Vim</label>

      <input type="radio" id="clean"
             name="quest" value="clean">
      <label for="contactChoice2">Clean up</label>
  </div>
  <script>
   document.addEventListener('click',
                             function(event){
                                 $.selectElement('questChoice').value('clean_up');
                             });
  </script>
#+END_SRC

Before I reveal your choice to you I want to quickly show you ~slack-select-room~ which can be found in [[https://github.com/yuya373/emacs-slack/blob/master/slack-room.el#L256][slack-room.el]]
#+BEGIN_SRC emacs-lisp
(defun slack-select-rooms ()
  (interactive)
  (let* ((team (slack-team-select))
         (room (slack-room-select
                (cl-loop for team in (list team)
                         append (with-slots (groups ims channels) team
                                  (append ims groups channels))))))
    (slack-room-display room team)))
#+END_SRC

~slack-select-room~ is a lot like the code I had previously used to choose where to post my message, ~slack-select-channel~, but this allows us to post in any slack room including channels, ims, and groups.

** Back to our regularly scheduled program
You have chosen "clean up"! A brave choice indeed!

** Previously on the X-Files...
[[./images/x-files-mulder-scully.jpg]]

I had figured out how to share any region of a buffer in Emacs and send it to Slack with it decorated as code.
#+BEGIN_SRC emacs-lisp tangle
  (defun jb/send-region-to-slack-code ()
    (interactive)
    (let* ((team (slack-team-select))  ;; Get all rooms from selected team
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (concat "```" (filter-buffer-substring (region-beginning) (region-end)) "```")
                                   (oref room id)
                                   team)))
#+END_SRC

Unfortunately, that isn't enough for me! I don't always want to demarcate text as code, sometimes I just want to send naked text.

#+BEGIN_SRC emacs-lisp
(defun jb/send-region-to-slack ()
  (interactive)
  (let ((team (slack-team-select)) ;; Select team
        (room (slack-room-select
               (cl-loop for team in (list team)
                        for channels = (oref team channels)
                        nconc channels)))) ;; Get all rooms from selected team
    (slack-message-send-internal (filter-buffer-substring (region-beginning) (region-end))
                                 (oref room id)
                                 team)))
#+END_SRC

Or I want to have my text dress-up and be all snappy in quotes!
#+BEGIN_SRC emacs-lisp
  (defun jb/send-region-to-slack-quotes ()
    (interactive)
    (let* ((team (slack-team-select))  ;; Get all rooms from selected team
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (concat "> " (filter-buffer-substring (region-beginning) (region-end)))
                                   (oref room id)
                                   team)))
#+END_SRC

[[./images/its_not_working.gif]]

** Wait A Minute
[[./images/why_isnt_it_working.gif]]

Apparently, in Markdown's [[https://daringfireball.net/projects/markdown/syntax#blockquote][inifinite wisdom]], they made it so that each line of text you want to quote has to be preceded by "> ".

** Houston We Have A Problem
I've run into a big problem. I don't know how to iterate through text in a buffer.

Iterating through a list of strings is easy after all this is lisp, the language is meant for processing lists! Below, all I had to do was [[https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html][mapcar]] over a list of strings and concat "> " to the beginning of each item.

#+BEGIN_SRC emacs-lisp
  (setq quotes '("I hope he didn’t die. Unless he left a note naming me his successor, then I hope he did die."
                    "I’m so embarrassed. I wish everybody else was dead."
                    "Have you ever tried simply turning off your TV, sitting down with your child, and hitting them?"))

  (mapcar (lambda (line) (concat "> " line)) quotes)
#+END_SRC

#+RESULTS:
| > I hope he didn’t die. Unless he left a note naming me his successor, then I hope he did die.    |
| > I’m so embarrassed. I wish everybody else was dead.                                             |
| > Have you ever tried simply turning off your TV, sitting down with your child, and hitting them? |

But if we step this up a notch and apply this to work on a region, we get an error letting us know that we are not doing what we think we are doing.

#+BEGIN_SRC emacs-lisp
    (defun quote-region ()
      (interactive)
      (message
       (mapcar (lambda (line) (concat "> " line))
                       (filter-buffer-substring (region-beginning) (region-end)))))
#+END_SRC

#+RESULTS:
| Wrong type argument: sequencep, 40 |

** Text Oddity
[[./images/BowieSpaceOddity.jpg]]

No, not Space Oddity.

As a beginner, I find interactive and programmatic text processing in Emacs to be an oddity. I have built up an intuition on how to deal with string manipulation in other environments and that doesn't map well to the way Emacs thinks about strings, or particularly text in buffers.

Here I have an expanded version of ~quote-region~, where I try to convert a buffer region into a list of strings and then apply my transformation to each string.

#+BEGIN_SRC emacs-lisp
  (defun quote-region ()
    (interactive)
    (message
     (mapcar (lambda (line) (concat "> " line))
             (split-string
              (filter-buffer-substring (region-beginning) (region-end))
              "\n"
              t))))
#+END_SRC

Surprisingly, this got me a lot farther, but now I'm hitting a type error somewhere. It's pretty easy to guess the ~message~ function is causing us problems. By looking at the function signature of message, ~(message FORMAT-STRING &rest ARGS)~, it confirms my suspicion. Which means all I need to do is join this list of strings into one string and all of my woes will be solved.

#+RESULTS:
| Wrong type argument: stringp, (#("> Hello" 2 7 (fontified t font-lock-fontified t help-echo nil src-block t ws-butler-chg chg ...)) #("> World" 2 7 (fontified t font-lock-fontified t help-echo nil src-block t ws-butler-chg chg ...))) |

Voila, we have a function that operates on a region of a buffer, adds a quote marker to the beginning of each line and returns a string for us to be able to use elsewhere.
#+BEGIN_SRC emacs-lisp
  (defun quote-region ()
    (interactive)
    (message
     (string-join
      (mapcar (lambda (line) (concat "> " line))
              (split-string
               (filter-buffer-substring (region-beginning) (region-end))
               "\n"
               t))
      "\n")))
#+END_SRC

** Houston, we still have a problem

I now have a function that works, but it's hacky, way too hacky for me. I feel that text manipulation in a text editor has to be a lot easier than having to split a string, map over a list, then rejoin that string.

Unfortunately, I don't think the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Current-Buffer.html][documentation]] [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Excursions.html#Excursions][in]] [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Lines.html#Text-Lines][Emacs]] is really up to par with building up a good mental framework for how to programatically manipulate text. I had to do a [[http://ergoemacs.org/emacs/elisp_process_lines.html][lot]] of [[https://emacs.stackexchange.com/a/2193][googling]] to be able to point me in the right direction.

I realize that I'm in kind of a unique spot though. I want to: copy a region/buffer, mutate some text, provide this text as a return value from a function, and not mutate or changed them buffer I am currently in. Luckily Emacs has all of the tools to do this and some of them are very easy to find.

After a lot of reading and thinking I've settled on: I want to copy the current region into a temporary buffer, loop over each line until we hit the end, at the beginning of each line insert "> ", finally return the contents of this buffer once I've left the loop.[fn:1]
#+BEGIN_SRC emacs-lisp
  (defun jb/slack-quote-region (region)
    (with-temp-buffer
      (insert region)
      (goto-char 1) ;; Go to beginning of temporary buffer
      (while (> (point-max) (point)) ;; point is where cursor is in buffer, point-max is last position in buffer
        (beginning-of-line) ;; Always make sure we're at the beginning of the line
        (insert "> ") ;; Insert at point
        (forward-line 1)) ;; Go to next line
      (buffer-string))) ;; Return contents of temp buffer
#+END_SRC

Finally, we have something that works well and seems a lot more Emacs-ish.

#+BEGIN_SRC emacs-lisp
  (defun jb/send-region-to-slack-quotes ()
    (interactive)
    (let* ((team (slack-team-select))  ;; Get all rooms from selected team
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (jb/slack-quote-region (filter-buffer-substring (region-beginning) (region-end)))
                                   (oref room id)
                                   team)))
#+END_SRC

** I've Brought My Towel
#+BEGIN_QUOTE
In the beginning, the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move.
#+END_QUOTE

All right, after looking at everything I've written so far I don't like it. It's all very wet behind the ear code, and I think with a bit of forethought and a towel I can dry it up.

*** Like A Desert
Instead of having to call a different function for each decoration I want to apply to a region, I can take advantage of [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][Emacs' completion framework]].

A simple example of how the ~completing-read~ function works is that it takes in a prompt and a list of choices. When this function is run it prompts the user for a choice in the minibuffer and returns the users choice.

#+BEGIN_SRC emacs-lisp
  (setq choices '("It's amazing" "It's awesome" "Better than Vim"))
  (completing-read "What do you think of Emacs?: " choices)
#+END_SRC

I've decided to take things a step farther: I'm using an [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][alist]] as a key-value store. This alist is composed of text describing the decoration they want to apply and a lambda function that applies the transform to the buffer that's needed. I can take advantage of the fact that when ~completing-read~ is passed an association list it takes the CAR of each item in the list and presents those as the options for the user. I can use ~assoc~ to find the first entry in our alist that matches the choice made by the user, and then call that function on the selected region.
#+BEGIN_SRC emacs-lisp
  (setq decorators '(("None" . (lambda (text) text)) ;; The identity function
                     ("Code"  . (lambda (text) (concat "```" text "```")))
                     ("Quote"  . (lambda (text) (jb/slack-quote-region text)))))

  (defun decorate-text ()
    (interactive)
    (let ((decoration (completing-read "Select decoration: "
                                       decorators
                                       nil)
                                       t)
          (message (funcall (cdr (assoc decoration decorators)) "Oh yeah")))))
#+END_SRC

*** Like A Dessert

Finally, I've scoured the forbidden desert and found all the pieces necessary to create a simpler and easier to customize a solution for sending a region of text to Slack.

#+BEGIN_SRC emacs-lisp
  (with-temp-buffer
    (insert region)
    (goto-char 1)
    (while (> (point-max) (point))
      (beginning-of-line)
      (insert "> ")
      (forward-line 1))
    (buffer-string))

  (defun jb/decorate-text (text)
    (let* ((decorators '(("None" . (lambda (text) text))
                         ("Code"  . (lambda (text) (concat "```" text "```")))
                         ("Quote"  . (lambda (text) (jb/slack-quote-region text)))))
           (decoration (completing-read "Select decoration: "
                                        decorators
                                        nil
                                        t)))
      (funcall (cdr (assoc decoration decorators)) text)))

  (defun jb/send-region-to-slack ()
    (interactive)
    (let* ((team (slack-team-select))
           (room (slack-room-select
                  (cl-loop for team in (list team)
                           append (with-slots (groups ims channels) team
                                    (append ims groups channels))))))
      (slack-message-send-internal (jb/decorate-text (filter-buffer-substring
                                                      (region-beginning) (region-end)))
                                   (oref room id)
                                   team)))
#+END_SRC

Now
** Foot Notes
[fn:1] I think it's important to note that all operations happened based around point, cursor, this is why at the beginning of each loop we move point to the beginning of the line.
