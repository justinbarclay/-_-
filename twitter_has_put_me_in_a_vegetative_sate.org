* Like Gumby
The power and flexibility that Emacs, and it's suite of packages, constantly amazes me. I've been a big fan of `org-mode` for a long time, it's a great in Emacs replacement for Markdown and a number of other document formats, thanks to pandoc. `org-mode` is a great place to practice [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate programming]], but it's also a great place to an interactive style of programming, like a REPL or a Jupyter Notebook.

Lately, at work, I've been exploring a lot of Authenticated JSON APIs. Up until a couple of weeks ago, whenever I had to do this that would mean logging authenticating to the API using `curl` or `Postman`, copying the token and using it across sessions. Doing this in curl can be annoying, but `Postman` at least let's you set variables to use across the session.

However, with: Emacs, `org-mode`, and [[https://github.com/alf/ob-restclient.el][ob-restclient]], we can automate process further and share are work with out coworkers. I mean, that is if our coworkers had good taste and used Emacs over Vim, or Atom, or VSCode.

* Setup
First off, let's define a simple function to quickly clear out the result blocks in the current org file
#+BEGIN_SRC elisp
  (defun jb/org-clear-results ()
    (interactive)
    (org-babel-remove-result-one-or-many 't))
#+END_SRC

Now, let's set that to an easy to use key
#+BEGIN_SRC elisp
  (global-unset-key "\C-c\C-v\C-c")
  (global-set-key "\C-c\C-v\C-c" 'jb/org-clear-results)
#+END_SRC

We need a function to sanitize the response we get from restclient
#+BEGIN_SRC elisp
(defun sanitize-restclient-response (string)
 (string-trim (replace-regexp-in-string "^#\\+BEGIN_SRC js\\|^#\\+END_SRC\\|^//[[:print:]]+" "" string)))
#+END_SRC

* Preamble
I really like plants, and I love to learn random plant facts. So I am going to use [[https://trefle.io/reference][trefle.io]] API to tweet out facts about random plants.
* Demo
Let's give our source block a name, `#+NAME: trefle`, so we can easily reference it throughout the rest of our notebook. I am using my Mac's keychain to store and retrieve an access token I have stored for trefle.io.
#+NAME: trefle
#+BEGIN_SRC bash :results output
  security find-generic-password -gws trefle.io
#+END_SRC

To import a variable from earlier in the file you can use `:var token=trefle` where :var token, specified that you what to insert a variable called token into the proceeding block and the contents of that variable a pull from a block by the name of `trefle`. Now we just need to build the HTTP headers we're going to use for our interaction with trefle.
#+NAME: trefle-headers
#+BEGIN_SRC elisp :var token=trefle
  (concat
     "<<
  Content-Type: application/json
  Accept: application/json
  Authorization: Bearer " token)
#+END_SRC

As of the last time I looked, trefle.io has over 4000 pages of plants, so we want to get a random plant off of a random page. So to start, we'll generate a page number from 0 to 4000...
#+NAME: plants
#+BEGIN_SRC restclient :var headers=trefle-headers  :results value drawer
  #
  :page := (random 4000)
  GET https://trefle.io/api/plants?page=:page
  :headers
  #
#+END_SRC

Before we can do anything with the output we need to clean it up, restclient likes to have all the headers for the response at the bottom of the buffer, so we need to filter those out of the response.
#+NAME: sanitized-response
#+BEGIN_SRC elisp :var response=plants
(sanitize-restclient-response response)
#+END_SRC

Now we could use elisp, but everyone has NodeJS installed and NodeJS is pretty much built for parsing JSON, so it only makes sense to use that. So we'll grab a random plant from the sanitized results and return it's ID.

#+NAME: plant-name
#+BEGIN_SRC js :var plants=sanitized-response :results value drawer
  let index = Math.floor(Math.random() * 30);
  return JSON.parse(plants)[index].scientific_name;
#+END_SRC

Now, I need to get my Google API key, for this I've been lazy and have just been storing it as an ENV var.
#+NAME: google-api-key
#+BEGIN_SRC bash
echo "AIzaSyBt6r9cLqILZV_i4gdeFjLtufDnCJd_G4I"
#+END_SRC

Now that we've got a plant name, let's get an image to use to give an example of the plant.

#+NAME: google-images
#+BEGIN_SRC restclient :var api-key=google-api-key plant-name=plant-name
  GET https://content.googleapis.com/customsearch/v1?cx=009341007550343915479%3Afg_hsgzltxw&q=:plant-name&searchType=image&key=:api-key
#+END_SRC

Now much like our search for a plant name, we need to clean up the response from google API so it's easily parsable as JSON.
#+NAME: flower-images
#+BEGIN_SRC elisp :var google-images=google-images
  (sanitize-restclient-response google-images)
#+END_SRC


Now that we have a nice list of plants, let's play google roulette and use the first image from the search

#+NAME: plant-image
#+BEGIN_SRC js :var plant_images=flower-images :results value drawer
  return JSON.parse(plant_images).items[0].link
#+END_SRC
